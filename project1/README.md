# Project_1:FIR Filter Design
---
## FIR11
>实现顶层函数验证函数正确性并熟悉Vitis_HLS的模拟以及综合流程。

- 获取以下脚本以运行Vitis：

      source <VITIS_install_path>/settings64.sh
      source <XRT_install_path>/setup.sh

- 确保以下环境变量指向平台安装路径：
  
      export PLATFORM_REPO_PATHS=<path to the U250 platforminstall dir>
- 运行VitisHLS：
      
      vitis_hls -f <name.tcl> #以name.tcl创建项目
  也可手动添加源文件和顶层函数。
- 进行仿真及综合
  
      cosim_design/csim_design/csynth_design   #进行C/RTL协同仿真 /C仿真/C综合。

- 运行报告保存在项目文件夹下。
  
- 更多HLS命令执行help查看
---
## FIR128 
>对FIR Filter Design进行多种优化，理解不同优化对设计的影响。
### baseline
实现与FIR11相同。
- Performance & Resource

      +----------------------------------+------+------+---------+-----------+----------+---------+------+----------+--------+---------+-----------+-----------+-----+
      |              Modules             | Issue|      | Latency |  Latency  | Iteration|         | Trip |          |        |         |           |           |     |
      |              & Loops             | Type | Slack| (cycles)|    (ns)   |  Latency | Interval| Count| Pipelined|  BRAM  |   DSP   |     FF    |    LUT    | URAM|
      +----------------------------------+------+------+---------+-----------+----------+---------+------+----------+--------+---------+-----------+-----------+-----+
      |+ fir                             |     -|  0.39|      135|  1.350e+03|         -|      136|     -|        no|  3 (1%)|  2 (~0%)|  577 (~0%)|  305 (~0%)|    -|
      | + fir_Pipeline_Shift_Accum_Loop  |     -|  0.39|      133|  1.330e+03|         -|      133|     -|        no|  3 (1%)|  2 (~0%)|  510 (~0%)|  246 (~0%)|    -|
      |  o Shift_Accum_Loop              |     -|  7.30|      131|  1.310e+03|         5|        1|   128|       yes|       -|        -|          -|          -|    -|
      +----------------------------------+------+------+---------+-----------+----------+---------+------+----------+--------+---------+-----------+-----------+-----+

### 可变位宽
> ap_int <>

*仅修改非参数的变量。*

    ap_int<5> c[N]
	ap_int<8> shift_reg[N];
	ap_int<16> acc;
**如何计算所需的最小位宽？**
  对于**c**,我们可以观察到绝对值的最大值为11,$log_2(11)<4, $因为我们需要有符号数，因此至少4+1=5位。
  观察**shift_reg**发现，**shift_reg=x**,因此**shift_reg**的位宽要保证不丢失**x**的精度，与计算c位宽相同，我们可以得到至少为8位。
  而对于**acc**，我们观察以下代码计算**acc**的位宽需求：

    acc = 0;
    Shift_Accum_Loop:
    for(i = N - 1;i >= 0;i--){
        if(i == 0){
            acc += x * c[0];
            shift_reg[0] = x;
        }else {
            shift_reg[i] = shift_reg[i - 1];
            acc += shift_reg[i] * c[i];
        }
    }
**acc**由**c**与**shift_reg**的乘积累加得到，我们知道对于a=b\*c，a的位宽需要为b的b和c的位宽之和，而a=b+c，a的位宽为max(b,c)+1。因此shift_reg\*c的位宽最大为13。
对于累加计算，如果我们利用a=b+c的位宽计算公式，我们会得到acc的位宽在每次加法操作时都需要增加1才能保证不溢出，通过这种方法得到的位宽为13+N-1=140；显然并不需要这么高的位宽。

此时我们应该考虑将累加操作近似为shift_reg\*c\*N,此时我们得到安全位宽应为13+8=21。
但是在实验中我们可以发现并非所有的shift_reg*c都等于$2^{13}-1$，因此我们通过实验得到针对此例更加冒险的位宽设置，即16。

    Comparing against output data
    *******************************************
    PASS: The output matches the golden output!
    *******************************************
在实际的工程中，可以根据需求具体选择位宽，因为位宽的选择关系到资源的利用情况，位宽减小后的资源利用情况如下：

    +----------------------------------+------+------+---------+-----------+----------+---------+------+----------+---------+----+-----------+-----------+-----+
    |              Modules             | Issue|      | Latency |  Latency  | Iteration|         | Trip |          |         |    |           |           |     |
    |              & Loops             | Type | Slack| (cycles)|    (ns)   |  Latency | Interval| Count| Pipelined|  BRAM   | DSP|     FF    |    LUT    | URAM|
    +----------------------------------+------+------+---------+-----------+----------+---------+------+----------+---------+----+-----------+-----------+-----+
    |+ fir                             |     -|  0.59|      134|  1.340e+03|         -|      135|     -|        no|  1 (~0%)|   -|  212 (~0%)|  274 (~0%)|    -|
    | + fir_Pipeline_Shift_Accum_Loop  |     -|  0.59|      132|  1.320e+03|         -|      132|     -|        no|  1 (~0%)|   -|  169 (~0%)|  231 (~0%)|    -|
    |  o Shift_Accum_Loop              |     -|  7.30|      130|  1.300e+03|         4|        1|   128|       yes|        -|   -|          -|          -|    -|
    +----------------------------------+------+------+---------+-----------+----------+---------+------+----------+---------+----+-----------+-----------+-----+
_可以发现资源占用明显减少，可变位宽大大提高了计算能效。_

### 流水线
>设置流水线并显式设置不同启动间隔，观察对延迟的影响。

将以下命令添加到for loop前：
    
    #pragma HLS pipeline II=1

逐渐增加II启动间隔，发现最小latency=6，在II=1时即可实现，但是资源占用较大（  FF
:2592 (2%)|  LUT:3020 (5%)）。相同latency的情况下，II=4时资源占用更低（  1722 (1%)|  2743 (5%)）。不论那种情况，流水线操作都大大提高了程序的运行效率。latency:135->6，同时也增大了资源占用，以额外的资源提高吞吐量。

### 删除条件语句

>if/else会降低程序的可并行性而且通常占用额外资源，因此在 并行设计中应尽量避免。

源代码中，if/else语句来自于i=0时的特判，因此将i=0的情况移出循环，设计如下：

    for(i = N-1;i > 0;i--){
      shift_reg[i] = shift_reg[i-1];
      acc += shift_reg[i] * c[i];
    }

    acc += x * c[0];
    shift_reg[0] = x;

此优化对于延迟几乎没有影响，但是很明显改变后的代码并行可行度更高，有利于进一步优化。
另外，删除if/else降低了部分资源占用
    
    before：
     BRAM  |   DSP   |     FF    |    LUT   
     3 (1%)|  2 (~0%)|  577 (~0%)|  305 (~0%)
    after：
     BRAM  |   DSP   |     FF    |    LUT   
      1    |  1 (~0%)|  130 (~0%)|  214 (~0%)

### 循环分区
>通过循环分区可以分别对每个循环分别进行展开以及流水线操作，提高性能提升潜力。

- 通过观察我们不难发现for loop中共进行了两件事，数据移位和乘累加，且数据移位发生在乘累加操作之前，于是可以将循环拆分为DTL和MAC两个循环单独执行。如下：
  
      DTL:
      for(i = N - 1;i > 0;i--){	
        shift_reg[i] = shift_reg[i - 1];	
      }
      shift_reg[0] = x;
      acc = 0;
      MAC:
      for(i = N - 1;i >= 0;i--){
        acc += shift_reg[i] * c[i];	
      }
对于分区后的循环我们可以通过分别进行展开和流水线操作实现优化。

### 内存分区
> 通过对变量的内存分区，我们可以实现面积和带宽的trade-off，实现所需的设计。

对比发现，在相同的factor下，cyclic和block的资源占用情况相同，complete的资源占用最高(显然)

-*性能在下一部分综合优化中提到*

### 综合优化
**?**
感觉可能是功能太简单了,所以优化的影响不明显,最小latency=6.
